

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>设计测试用例 &mdash; Testbase 5.0.0 文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Testbase 5.0.0 文档" href="index.html"/>
        <link rel="next" title="执行测试用例" href="testcaserun.html"/>
        <link rel="prev" title="创建和修改测试项目" href="project.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> Testbase
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">使用前准备</a><ul>
<li class="toctree-l2"><a class="reference internal" href="setup.html#python">安装Python和相关工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="setup.html#qtaf">获取QTAF包</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="project.html">创建和修改测试项目</a><ul>
<li class="toctree-l2"><a class="reference internal" href="project.html#id2">创建测试项目</a></li>
<li class="toctree-l2"><a class="reference internal" href="project.html#eclipse">导入测试项目到Eclipse</a></li>
<li class="toctree-l2"><a class="reference internal" href="project.html#id3">测试项目结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="project.html#qtaf">升级QTAF</a></li>
<li class="toctree-l2"><a class="reference internal" href="project.html#egg">安装依赖的Egg</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">设计测试用例</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">最简单的测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">调试执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">测试断言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">忙等待检查</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">测试执行控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">测试环境初始化和清理</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testcaserun.html">执行测试用例</a><ul>
<li class="toctree-l2"><a class="reference internal" href="testcaserun.html#id2">重复执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="testcaserun.html#id3">控制执行顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="testcaserun.html#id4">自定义执行方式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testresult.html">处理测试结果</a><ul>
<li class="toctree-l2"><a class="reference internal" href="testresult.html#id2">测试通过与不通过</a></li>
<li class="toctree-l2"><a class="reference internal" href="testresult.html#id3">测试日志</a></li>
<li class="toctree-l2"><a class="reference internal" href="testresult.html#id4">测试结果对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="testresult.html#id5">测试日志的级别</a></li>
<li class="toctree-l2"><a class="reference internal" href="testresult.html#id6">异常时日志</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testmgr.html">管理测试用例</a><ul>
<li class="toctree-l2"><a class="reference internal" href="testmgr.html#id2">组织形式</a></li>
<li class="toctree-l2"><a class="reference internal" href="testmgr.html#id3">加载测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="testmgr.html#id4">处理加载失败</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="datadrive.html">数据驱动测试</a><ul>
<li class="toctree-l2"><a class="reference internal" href="datadrive.html#id2">数据驱动测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="datadrive.html#id3">测试数据</a><ul>
<li class="toctree-l3"><a class="reference internal" href="datadrive.html#list">list类型测试数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="datadrive.html#dict">dict类型测试数据</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="datadrive.html#id4">管理数据驱动测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="datadrive.html#id5">调试数据驱动测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="datadrive.html#id6">全局数据驱动测试</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="testrun.html">执行测试</a><ul>
<li class="toctree-l2"><a class="reference internal" href="testrun.html#id2">批量执行测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="testrun.html#id3">指定测试报告类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="testrun.html#id4">并发执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="testrun.html#id5">指定测试用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="testrun.html#id6">自定义测试执行</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">配置测试项目</a><ul>
<li class="toctree-l2"><a class="reference internal" href="settings.html#id2">配置语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="settings.html#id3">配置文件路径</a></li>
<li class="toctree-l2"><a class="reference internal" href="settings.html#id4">使用测试配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="settings.html#id5">增加配置项</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">接口文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api/conf.html"><code class="docutils literal"><span class="pre">testbase.conf</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/context.html"><code class="docutils literal"><span class="pre">testbase.context</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/datadrive.html"><code class="docutils literal"><span class="pre">testbase.datadrive</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/exlib.html"><code class="docutils literal"><span class="pre">testbase.exlib</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/loader.html"><code class="docutils literal"><span class="pre">testbase.loader</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/logger.html"><code class="docutils literal"><span class="pre">testbase.logger</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/management.html"><code class="docutils literal"><span class="pre">testbase.management</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/project.html"><code class="docutils literal"><span class="pre">testbase.project</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/report.html"><code class="docutils literal"><span class="pre">testbase.report</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/resource.html"><code class="docutils literal"><span class="pre">testbase.resource</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/runner.html"><code class="docutils literal"><span class="pre">testbase.runner</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/serialization.html"><code class="docutils literal"><span class="pre">testbase.serialization</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/testcase.html"><code class="docutils literal"><span class="pre">testbase.testcase</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/testresult.html"><code class="docutils literal"><span class="pre">testbase.testresult</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/util.html"><code class="docutils literal"><span class="pre">testbase.util</span></code> Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="settingslist.html">配置项说明文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="settingslist.html#debug">DEBUG</a></li>
<li class="toctree-l2"><a class="reference internal" href="settingslist.html#data-drive">DATA_DRIVE</a></li>
<li class="toctree-l2"><a class="reference internal" href="settingslist.html#data-srouce">DATA_SROUCE</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Testbase</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>设计测试用例</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/testcase.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1>设计测试用例<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>最简单的测试用例<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>下面我们来编写第一个QTA测试用例，在测试项目中新建一个hello.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">testbase.testcase</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">HelloTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;第一个测试用例</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_step</span><span class="p">(</span><span class="s">&quot;第一个测试步骤&quot;</span><span class="p">)</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>可以看到，这个最简单的测试用例包括以下主要的部分：</p>
<blockquote>
<div><blockquote>
<div><ul>
<li><p class="first">一个测试用例就是一个Python类，类的名称就是测试用例名，类的DocString就是测试用例的简要说明文档。注意DocString对于QTA测试用例而言是必要的，否则会导致执行用例失败。</p>
</li>
<li><p class="first">测试用例类包括四个必要的属性：</p>
<blockquote>
<div><ul class="simple">
<li>owner，测试用例负责人，必要属性。</li>
<li>status，测试用例状态，必要属性。目前测试用例有五种状态：Design、Implement、Review、Ready、Suspend。</li>
<li>priority，测试用例优先级，必要属性。目前测试用例有四种优先级：BVT、High、Normal和Low。</li>
<li>timeout，测试用例超时时间，必要属性，单位为分钟。超时时间用于指定测试用例执行的最长时间，如果测试用例执行超过此时间，执行器会停止用例执行，并认为用例执行超时，测试不通过。一般来说，不建议这个时间设置得太长，如果用例需要比较长的执行时间，可以考虑拆分为多个测试用例。</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>run_test函数：这个是测试逻辑的代码，每个测试用例只有一个唯一的run_test函数；但每个测试用例可以划分为多个测试步骤，测试步骤以start_step函数调用来分隔。</li>
</ul>
</div></blockquote>
<p>以上的测试用例并没有任何测试逻辑，只是调用接口打印一行日志。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">由于历史的原因，QTA很多接口的函数有两种代码风格的版本，比如上面的run_test、log_info，就有对应的mixedCase的版本runTest、logInfo。一般情况下，建议和测试项目已有的代码使用一致的风格的接口，如果是新项目，推荐使用lower_with_under风格的接口。</p>
</div>
</div>
<div class="section" id="id3">
<h2>调试执行<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>测试用例编写后，需要进行调试执行。需要在hello.py中增加以下的代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
   <span class="n">HelloTest</span><span class="p">()</span><span class="o">.</span><span class="n">debug_run</span><span class="p">()</span>
</pre></div>
</div>
<p>如果使用的是IDE，在eclipse中，通过“CTRL + F11”快捷键执行当前hello.py脚本，可以看到输出如下:</p>
<div class="highlight-python"><div class="highlight"><pre>============================================================
测试用例:HelloTest 所有者:eeelin 优先级:Normal 超时:1分钟
============================================================
----------------------------------------
步骤1: 第一个测试步骤
INFO: hello
============================================================
测试用例开始时间: 2015-04-27 12:51:59
测试用例结束时间: 2015-04-27 12:51:59
测试用例执行时间: 00:00:0.00
测试用例步骤结果:  1:通过
测试用例最终结果: 通过
============================================================
</pre></div>
</div>
<p>如果没有使用IDE，可以通过manage.py执行单个用例:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python manage.py runscript footest/hello.py
</pre></div>
</div>
<p>在命令行窗口可以看到一样的执行输出:</p>
<div class="highlight-python"><div class="highlight"><pre>============================================================
测试用例:HelloTest 所有者:eeelin 优先级:Normal 超时:1分钟
============================================================
----------------------------------------
步骤1: 第一个测试步骤
INFO: hello
============================================================
测试用例开始时间: 2015-04-27 12:51:59
测试用例结束时间: 2015-04-27 12:51:59
测试用例执行时间: 00:00:0.00
测试用例步骤结果:  1:通过
测试用例最终结果: 通过
============================================================
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>测试断言<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>上面的测试代码没有任何测试的逻辑，并不算是一个完整的测试用例。下面我们通过一个例子来介绍QTA的两个测试检查接口。</p>
<p>假设我们需要测试一个字符串拼接的函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">string_combine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<p>测试用例的代码如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">testbase.testcase</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">StrCombineTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;测试字符串拼接接口</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_step</span><span class="p">(</span><span class="s">&quot;测试字符串拼接&quot;</span><span class="p">)</span>
        <span class="c">#---------------------------</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">string_combine</span><span class="p">(</span><span class="s">&quot;xxX&quot;</span><span class="p">,</span> <span class="s">&quot;yy&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="s">&quot;检查string_combine调用结果&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="s">&quot;xxXyy&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>以上的代码执行结果如下:</p>
<div class="highlight-python"><div class="highlight"><pre>============================================================
测试用例:StrCombineTest 所有者:eeelin 优先级:Normal 超时:1分钟
============================================================
----------------------------------------
步骤1: 测试字符串拼接
============================================================
测试用例开始时间: 2016-02-02 14:10:21
测试用例结束时间: 2016-02-02 14:10:21
测试用例执行时间: 00:00:0.00
测试用例步骤结果:  1:通过
测试用例最终结果: 通过
============================================================
</pre></div>
</div>
<p>可以看到结果是测试通过的，但是如果string_combine实现有问题，比如我们新定义一个string_combine2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">string_combine2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="s">&#39;b&#39;</span>
</pre></div>
</div>
<p>以为以上的实现是有问题，执行结果必然是不通过的:</p>
<div class="highlight-python"><div class="highlight"><pre>============================================================
测试用例:StrCombineTest 所有者:eeelin 优先级:Normal 超时:1分钟
============================================================
----------------------------------------
步骤1: 测试字符串拼接
ASSERT: 检查string_combine2调用结果
   实际值：xxXb
   期望值：xxXyy
  File &quot;D:\workspace\qtaf5\test\hellotest.py&quot;, line 87, in run_test
============================================================
测试用例开始时间: 2016-02-02 14:11:45
测试用例结束时间: 2016-02-02 14:11:45
测试用例执行时间: 00:00:0.00
测试用例步骤结果:  1:失败
测试用例最终结果: 失败
============================================================
</pre></div>
</div>
<p>可以看到除了测试不通过外，测试结果还显示了断言失败的详细信息，包括预期值、实际值和对应的代码行。</p>
<p>这个就是QTA提供的测试断言的函数接口，其详细的定义如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">assert_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">expect</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;检查实际值和期望值是否相等，不能则测试用例失败</span>

<span class="sd">   :param message: 检查信息</span>
<span class="sd">   :param actual: 实际值</span>
<span class="sd">   :param expect: 期望值(默认：True)</span>
<span class="sd">   :return: True or False</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<p>除了这个，QTA还提供另一个版本的断言函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">assert_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">expect</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;检查actual和expect是否模式匹配，不匹配则记录一个检查失败</span>

<span class="sd">    :type message: string</span>
<span class="sd">    :param message: 失败时记录的消息</span>
<span class="sd">    :type actual: string</span>
<span class="sd">    :param actual: 需要匹配的字符串</span>
<span class="sd">    :type expect: string</span>
<span class="sd">    :param expect: 要匹配的正则表达式</span>
<span class="sd">    :return: True or False</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<p>assert_match和assert_equal的区别是，assert_match使用的是正则匹配而不是严格匹配，比如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="s">&quot;严格匹配断言&quot;</span><span class="p">,</span> <span class="s">&quot;XXX&quot;</span><span class="p">,</span> <span class="s">&quot;X*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>以上的断言是不通过的，但是对于下面的正则断言是通过的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">assert_match</span><span class="p">(</span><span class="s">&quot;正则匹配断言&quot;</span><span class="p">,</span> <span class="s">&quot;XXX&quot;</span><span class="p">,</span> <span class="s">&quot;X*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>assert_match和assert_equal相比，还有一个区别就是，assert_match只支持字符串或字符串兼容的类型的值的检查；但是assert_equal可以支持大部分类型的值的检查。</p>
</div>
<div class="section" id="id5">
<h2>忙等待检查<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>以上的两个断言的检查的接口，都是检查某个时刻的被测系统的状态。但是对于一些系统，特别是UI，如果仅仅调用assert_equal和assert_match接口去检查当前的状态其实是不恰当的。</p>
<p>例如，一个表单的UI界面，如果点击“提交”后，我们需要检查“提交”按钮变为不可点击的状态，测试用例可能是这样的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="s">&quot;检查“提交”按钮变为不可点击的状态&quot;</span><span class="p">,</span> <span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">enable</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的测试用例，存在一个问题，就是点击“提交”之后，“提交”按钮的状态的更新并不是同步的，可能由于被测系统响应慢了一点点，就会导致测试检查不通过，所以上面的测试用例代码段应该修改为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">enable</span><span class="p">:</span>
      <span class="k">break</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
   <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;等待超过2秒还是可以点击&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>以上的测试代码是在2秒之内，多次去检查“提交”按钮的状态是否符合预期。通过这样的“平滑”的方式，就可以避免由于被测系统状态同步问题而导致测试不稳定。</p>
<p>但是上面的测试代码还是相当复杂的，因此QTA测试用例提供了两个接口来帮忙解决这类问题:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">wait_for_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;每隔interval检查obj.prop_name是否和expected相等，如果在timeout时间内都不相等，则测试用例失败</span>

<span class="sd">    :param message: 失败时的输出信息</span>
<span class="sd">    :param obj: 需要检查的对象</span>
<span class="sd">    :type prop_name: string</span>
<span class="sd">    :param prop_name: 需要检查的对象的属性名，支持多层属性</span>
<span class="sd">    :param expected: 期望的obj.prop_name值</span>
<span class="sd">    :param timeout: 超时秒数</span>
<span class="sd">    :param interval: 重试间隔秒数</span>
<span class="sd">    :return: True or False</span>
<span class="sd">    &#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">wait_for_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;每隔interval检查obj.prop_name是否和正则表达式expected是否匹配，如果在timeout时间内都不相等，则测试用例失败</span>

<span class="sd">    :param message: 失败时的输出信息</span>
<span class="sd">    :param obj: 需要检查的对象</span>
<span class="sd">    :type prop_name: string</span>
<span class="sd">    :param prop_name: 需要检查的对象的属性名, obj.prop_name返回字符串</span>
<span class="sd">    :param expected: 需要匹配的正则表达式</span>
<span class="sd">    :param timeout: 超时秒数</span>
<span class="sd">    :param interval: 重试间隔秒数</span>
<span class="sd">    :return: True or False</span>
<span class="sd">    &#39;&#39;&#39;</span>
</pre></div>
</div>
<p>这两个其实就是assert_equal和assert_match的忙等待检查版本，通过wait_for系列的接口，上面的测试代码就可以简化为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">wait_for_equal</span><span class="p">(</span><span class="s">&quot;检查提交按钮变为不可点击&quot;</span><span class="p">,</span> <span class="n">form</span><span class="o">.</span><span class="n">controls</span><span class="p">[</span><span class="s">&#39;提交按钮&#39;</span><span class="p">],</span> <span class="s">&quot;enable&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>测试执行控制<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>QTA测试用例的代码的执行控制逻辑和一般Python的代码是类似的，所以除了执行过程中出现Python异常或用例执行超时，测试用例会一直执行。而且，即使是assert_和wait_for_系列的接口失败了，也会继续执行，比如下面的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CtrlTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;流程控制测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_step</span><span class="p">(</span><span class="s">&quot;断言失败&quot;</span><span class="p">)</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="s">&quot;检查断言&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_step</span><span class="p">(</span><span class="s">&quot;第二个步骤&quot;</span><span class="p">)</span>
        <span class="c">#---------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的第一个测试步骤中，有一个断言是必然失败的，但是第二个测试步骤还是会被正常执行:</p>
<div class="highlight-python"><div class="highlight"><pre>============================================================
测试用例:CtrlTest 所有者:eeelin 优先级:Normal 超时:1分钟
============================================================
----------------------------------------
步骤1: 断言失败
ASSERT: 检查断言
   实际值：True
   期望值：False
  File &quot;D:\workspace\qtaf5\test\hellotest.py&quot;, line 86, in run_test
----------------------------------------
步骤2: 第二个步骤
INFO: hello
============================================================
测试用例开始时间: 2016-02-02 15:27:29
测试用例结束时间: 2016-02-02 15:27:29
测试用例执行时间: 00:00:0.00
测试用例步骤结果:  1:失败 2:通过
测试用例最终结果: 失败
============================================================
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">对于断言失败的执行逻辑处理，这个是QTA测试框架和其他一般测试框架比较大的差异点，设计测试用例是需要注意。</p>
</div>
</div>
<div class="section" id="id7">
<h2>测试环境初始化和清理<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>在前面的例子中，我们在测试用例类的run_test实现了测试的主要逻辑，这里我们引入两个新的接口pre_test和post_test。</p>
<p>假设我们的用例需要临时配置一个本地host域名，示例代码如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">testbase.testcase</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">EnvTest1</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;环境构造测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">_add_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>

        <span class="c"># main test logic here</span>
        <span class="c"># ...</span>

        <span class="n">_del_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>以上的代码在逻辑，在用例正常执行完成的情况下是完全正确的，但是这里存在一个问题，就是当run_test测试过程中，由于测试目标bug或者脚本问题导致run_test异常终止，则可能导致host配置没有删除，则可能影响到后面的测试用例。如何解决这个问题呢？QTA为此提供了post_test接口。</p>
<p>下面是使用post_test接口的新版本的测试用例代码:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">testbase.testcase</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">EnvTest2</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;环境构造测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">_add_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>

        <span class="c"># main test logic</span>
        <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">post_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EnvTest2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">post_test</span><span class="p">()</span>
        <span class="n">_del_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>QTA执行用例的接口是先执行run_test，然后执行post_test；而且即使测试用例执行run_test中发生异常，仍会执行post_test，这样就保证了测试环境的清理操作。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">虽然使用post_test可以保证清理环境，但是还是要注意清理环境的逻辑要尽量简单，否则清理环境时发生异常，也会导致清理动作未完成。</p>
</div>
<p>和post_test对应，QTA还提供了pre_test接口，从名字上看以看出，pre_test的作用主要是用于测试环境的构造和初始化，下面是使用pre_test的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EnvTest3</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;环境构造测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">pre_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_add_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EnvTest3</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pre_test</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># main test logic</span>
        <span class="c"># ...</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">post_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EnvTest3</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">post_test</span><span class="p">()</span>
        <span class="n">_del_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>QTA会依照以下顺序执行测试用例的三个接口:</p>
<blockquote>
<div><ul class="simple">
<li>pre_test</li>
<li>run_test</li>
<li>post_test</li>
</ul>
</div></blockquote>
<p>且任意一个接口执行异常，QTA仍然会执行下一个接口。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">由于历史原因，QTA还提供另一套代码风格的接口preTest、runTest和postTest，建议测试用例编写时选择测试项目存量代码统一的代码风格，如果是新的测试项目还是建议使用lower_with_under的代码风格。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">在一个测试用例中仅支持一套代码风格的接口，QTA选择接口的代码风格是基于run_test/runTest选择的风格为主，也就是说如果用例定义了runTest，则只会执行preTest和postTest，但不会执行pre_test和post_test。当run_test和runTest两个接口都存在的时候，QTA优先选择run_test接口来执行。</p>
</div>
<p>pre_test这个接口的一个作用是可以提高测试用例代码的复用，比如以下的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">testbase.testcase</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">EnvTestBase</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">pre_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EnvTestBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">post_test</span><span class="p">()</span>
        <span class="n">_add_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">post_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EnvTestBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">post_test</span><span class="p">()</span>
        <span class="n">_del_host</span><span class="p">(</span><span class="s">&quot;www.qq.com&quot;</span><span class="p">,</span> <span class="s">&quot;11.11.12.12&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">EnvTest4</span><span class="p">(</span><span class="n">EnvTestBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;环境构造测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># code 1</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">EnvTest5</span><span class="p">(</span><span class="n">EnvTestBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;环境构造测试</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">owner</span> <span class="o">=</span> <span class="s">&quot;eeelin&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumStatus</span><span class="o">.</span><span class="n">Ready</span>
    <span class="n">priority</span> <span class="o">=</span> <span class="n">TestCase</span><span class="o">.</span><span class="n">EnumPriority</span><span class="o">.</span><span class="n">Normal</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># code 2</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>可以看到EnvTest4和EnvTest5的基类都是为EnvTestBase，也就是他们本身会继承基类的pre_test和post_test的实现，因此也会进行环境的初始化和清理的动作。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">可以看到EnvTestBase的pre_test和post_test方法都调用的super接口，对于Python语言的含义表示的是调用基类的方法，虽然不是必定需要的，但是大部分情况下还是推荐这样做；因为这样做可以保证基类的初始化和清理的接口会被执行。</p>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="testcaserun.html" class="btn btn-neutral float-right" title="执行测试用例" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="project.html" class="btn btn-neutral" title="创建和修改测试项目" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2016, QTA.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'5.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>