#-*- coding: utf-8 -*-
'''处理当前代码并生成对应的开源版本

主要按照顺序做以下处理：

1、生成开源版本对应的setup.py和requirements.txt，需要这样做的原因是部分集成在QTAF代码中的库由于证书问题修改为外部依赖，
所以requirements会增加，其次是内部版本的QTAF有区分all、testbase等版本，但开源的代码不区分多个版本

2、移除掉一些内部平台相关的代码；主要有两种操作：
（1）移除DELETE_FILES定义的多余的文件
（2）删除部分py文件中的部分代码，这个是由一个简单的预处理语言实现

3、为每个代码文件首部增加开源证书文本

4、扫描并替换代码注释中的RTX名字，这个是安全测的要求

5、处理RST文档，讲文档中的后缀为“.open.rst”的文件替换为对应的“.rst”文件

注意，这个Python文件也不应该发布到开源的代码中。

'''

#2017/10/20 olive 新建

import os
import re
import traceback
import sys
import locale
import shutil
import collections
import logging

BASE_DIR = os.path.realpath(os.path.dirname(__file__))

LICENSE_HEADER = """#
# Tencent is pleased to support the open source community by making QTA available.
# Copyright (C) 2016THL A29 Limited, a Tencent company. All rights reserved.
# Licensed under the BSD 3-Clause License (the "License"); you may not use this 
# file except in compliance with the License. You may obtain a copy of the License at
# 
# https://opensource.org/licenses/BSD-3-Clause
# 
# Unless required by applicable law or agreed to in writing, software distributed 
# under the License is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#
"""

#安全测要求不泄漏RTX名字到外网，使用这个名字映射，新人名需要加映射，请统一使用水果英文单词
RTX_NAME_MAP = {
    "rayechen": "apple",
    "allenpan" : "banana",
    "pillarzou": "organse",
    "tommyzhang": "cherry",
    "guyingzhao": "durian",
    "miawu": "carambola",
    "joyhu": "peach",
    "aaronlai": "pear",
    "jonliang": "persimmon",
    "eeelin": "olive",
    "dadalin": "sorgo",
    "terisli": "tangor",
    "shadowyang": "rambutan",
    "brutuswu": "strawberry",
    "natusmewei": "kiwifruit",
}

DELETE_FILES = [
    ("build.py",),
    ("sync_from_svn.py",),
    ("testbase", "platform"),
    ("testbase", "_rscitf.py"),
    ("testbase", "resource.py"),
    ("pyqq",),
    ("test",),
    ("tuia", "ply"),
    ("docs",u"QTAF打包和发布流程.doc")
]

#开源版本增加的依赖包
ADDITIONAL_REQUIREMENTS = [
    "ply",
]

SETUP_PY_TMPL = """
#
# Auto generated by process_to_open.py
#

from setuptools import setup, find_packages

if __name__ == "__main__":
    
    setup(
      version="%(version)s",
      name="qtaf",
      packages=find_packages(),
      py_modules=["__main__", "qtaf_settings"],
      package_data={'':['*.lib', '*.txt', '*.TXT', '*.exe', '*.lib'], },
      data_files=[(".", ["requirements.txt", "LICENSE.TXT"])],
      author="Tencent",
      license="Copyright(c)2010-2017 Tencent All Rights Reserved. ",
      requires=%(requirements)s,   
      entry_points={'console_scripts': ['qta-manage = testbase.management:qta_manage_main'], },
      )
      
      
"""


class ProcessorSyntaxError(Exception):
    '''预处理语法错误
    '''
    def __init__(self, msg, file_path, lineno ):
        error = "%s at %s:%s" % (msg, file_path, lineno)
        super(ProcessorSyntaxError,self).__init__(error)

def preprocess_pyfile( file_path, context ):
    '''预处理Python文件中的宏，其中VAR定义在context变量中
    '''
    result = ""
    with open(file_path, 'r') as fd:
    
        conds = collections.deque([True])
        changed = False
        
        for lineno, line in enumerate(fd.readlines()):
            accept = conds[-1]
            
            sline = line.strip()
            if sline.startswith("#@"):
                changed = True
                
                tokens = sline[2:].split()
                if len(tokens) == 0:
                    raise ProcessorSyntaxError("need operator", file_path, lineno)
                operator = tokens[0]
                params = tokens[1:]
                if operator == 'ifdef':
                    if accept:
                        if len(params) < 1:
                            raise ProcessorSyntaxError("operator need parameter", file_path, lineno)
                        if params[0] in context:
                            conds.append(True)
                        else:
                            conds.append(False)
                        
                elif operator == 'ifndef':
                    if accept:
                        if len(params) < 1:
                            raise ProcessorSyntaxError("operator need parameter", file_path, lineno)
                        if params[0] not in context:
                            conds.append(True)
                        else:
                            conds.append(False)
                        
                elif operator == 'endif':
                    conds.pop()
                    
                else:
                    raise ProcessorSyntaxError("invalid operator `%s`" % operator, file_path, lineno)
                
 
            else:
                if accept:
                    result += line
                
    if changed:
        logging.info("preprocessing: %s" % file_path)
        with open(file_path, 'w') as fd:
            fd.write(result)
        
def add_license_header( filepath ):
    with open(filepath, 'r') as fd:
        if LICENSE_HEADER in fd.read():
            return
    with open(filepath, 'r') as fd:
        content = ""
        lineno = 0
        for line in fd.readline(): #跳过前面1-2行注释
            content += line
            if line.strip().startswith("#"):
                lineno += 1
            if lineno >= 2:
                break        
        content += LICENSE_HEADER
        content += fd.read()
        
    logging.info("add license for: %s" % filepath)
    with open(filepath, 'w') as fd:
        fd.write(content)

def replace_rtx_name( filepath ):
    if os.path.realpath(filepath) == __file__:
        return
    with open(filepath, 'r') as fd:
        content = fd.read()
    for orig in RTX_NAME_MAP:
        content = content.replace(orig, RTX_NAME_MAP[orig])
    with open(filepath, 'w') as fd:
        fd.write(content)
    
 
def generate_setup_py():
    requirements = []
    with open(os.path.join(BASE_DIR, "requirements.txt"), 'r') as fd:
        for line in fd.readlines():
            line = line.strip()
            if line:
                requirements.append(line)
    
    with open(os.path.join(BASE_DIR, "setup.py"), 'w') as fd:
        content = SETUP_PY_TMPL % dict(
            version="5.0.0",
            requirements=repr(requirements),
        )
        fd.write(content)
    
def process_req_txt():
    requirements = []
    with open(os.path.join(BASE_DIR, "requirements.txt"), 'r') as fd:
        for line in fd.readlines():
            line = line.strip()
            if line:
                requirements.append(line)
    
    for it in ADDITIONAL_REQUIREMENTS:
        if it not in requirements:
            requirements.append(it)
            
    with open(os.path.join(BASE_DIR, "requirements.txt"), 'w') as fd:
        for it in requirements:
            fd.write(it+"\n")
    
    
def process_rst_doc():
    
    for dirpath, dirnames, filenames in os.walk(BASE_DIR):
        for filename in filenames:
            if filename.endswith(".open.rst"):
                items = filename.rsplit(".",2)
                truename = items[0] + ".rst" 
                logging.info("process rst: %s -> %s" % (filename, truename))
                os.remove(os.path.join(dirpath, truename))
                os.rename(os.path.join(dirpath, filename),
                          os.path.join(dirpath, truename))
                
                
                
def main():
    process_req_txt()
    generate_setup_py()

    for names in DELETE_FILES:
        target = os.path.join(BASE_DIR, *names)
        if os.path.exists(target):
            if os.path.isdir(target):
                shutil.rmtree(target)
            else:
                os.remove(target)
                
    rtx_names = set()
    ppcontext = {"OPENSOURCE": "1"}
    for dirpath, dirnames, filenames in os.walk(BASE_DIR):
        for filename in filenames:
            if filename.endswith(".py"):
                filepath = os.path.join(dirpath, filename)
                preprocess_pyfile(filepath, ppcontext)
                add_license_header(filepath)
                replace_rtx_name(filepath)
             
                #scan rtx name
                with open(filepath, 'r') as fd:
                    for line in fd.readlines():
                        line = line.strip()
                        if line.startswith("#"):
                            items = line[1:].split()
                            if items and re.match("\d+/\d+/\d+", items[0]):
                                rtx_names.add(items[1].decode("utf-8"))  
        
    report = "user name detected:\n"
    for it in rtx_names:
        report += "%s\n" % it
    logging.info(report)
                           
    process_rst_doc()
    
    logging.info("delete myself")
    os.remove(__file__)
                           
if __name__ == '__main__':
    try:
        logging.root.level = logging.INFO
        logging.root.addHandler(logging.StreamHandler())
        main()
    except:
        traceback.print_exc()
